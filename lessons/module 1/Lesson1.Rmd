---
title: "Урок первый: векторы, типы данных, операторы и ветвления"
author: "Дмитрий Володин"
date: "`r Sys.Date()`"
output: html_document
---

## Векторы: базовые кирпичики языка

Никакой язык программирования не может существовать без данных, которые он
получает, изменяет и возвращает. Это могут быть различные структуры,
хранящиеся в памяти, но если их разобрать до основания, то обнаруживаются
базовые блоки данных. В R это вектор. В R не существует скалярных структур
данных. Даже `x = 5` - вектор из одного элемента. Понятие вектора в R близко к
математическому, советую воспринимать его именно так, как единый объект, при
изменении элемента которого мы получаем новый объект.

Вектор можно получить разными способами. Но по сути всё сводится либо к 
обращению к переменной, либо к вызову функции, которая возвращает объект. Нас
сейчас интересуют функции и операторы, которые возвращают простые векторы.

```{r eval=FALSE, include=FALSE}
c(7, 14, 21)
seq(1, 10, 2)
rep(1, 10)
5:55
c("Привет", "мир")
LETTERS
```

Мы видим несколько примеров функций и один оператор (но вообще это частный 
случай функции), которые возвращают векторы (числовые и строковые). А также 
видим обращение к встроенной переменной, являющейся ссылкой на участок памяти, 
где хранится вектор заглавных букв английского алфавита (это встроенная 
переменная). То есть переменная - это короткий адрес для доступа к конкретным 
данным в нашей сессии. В R нет прямой работы с памятью. Более того, почти все
объекты имутабельны, то есть в уже отведённом участке памяти вы не сможете 
поменять что-то. Даже малейшие изменения с данными, на которые ссылается
переменная, приводит к тому, что данные всем объёмом переезжают в новую область
памяти. Да, даже если вы назовёте переменную также. От этого ничего не зависит.

Для сохранения данных (векторов пока) в переменные для последующего 
использования в сессии используется оператор присваивания `<-`. Можно 
использовать знак "равно", но хорошим стилем считается именно оператор 
присваивания. А оператор равно используется для передачи данных в аргументы 
функции.

```{r eval=FALSE, include=FALSE}
x <- 42L
y <- 21
a <- 1:10
b <- "Hello, world!"

b
print(b)
```
С переменными потом можно проводить множество операций. Любые, которые позволяет
их тип и класс (об этом позже). Даже просто вызвав их, мы вызываем функцию 
вывода данных в консоль.

Переприсваивая переменную, мы теряем доступ к тем данным, на которые она 
указывала до этого. И даже если вам кажется, что есть другая переменная, которая
ссылается на те же самые данные, то это небольшая иллюзия, так как эти данные
прописаны по другому адресу, пусть и идентичны потерянным.

```{r eval=FALSE, include=FALSE}
c <- a
a <- 10:1
```

## Типы данных

Мы уже видели числа и строки (текст). Добавить сюда логический тип данных и 
картина будет почти полной. Типы данных определяют, какие операции доступны для
проведения над вектором. Ну и на низком уровне - как хранится объект в памяти
и как он воспринимается интерпретатором. Существуют пять типов данных:

```{r}
x_lgl <- c(TRUE, FALSE, NA) # логическийтип данных
x_int <- c(1L, 7L, 42L) # целочисленный тип
x_float <- c(1.5, 2, 3, 7e-32) # с плавающей запятой двойной точности
x_complex <- c(2i, 3, 3+2i) # комплексный тип
x_character <- c("1", "hello", "world") # строковый тип
```


Вектор, как единая структура может быть только одного типа. Не возможно создать 
вектор, у которого один элемент целочисленный, а другой строковый. Так как 
вектор создаётся вызовом функции, сработает приведение типов, то есть
интерпретатор попытается привести элементы разных типов к типу с наибольшим
приоритетом из тех, что представлены у элементов. Вот типы в порядке возрастания приоритета:

1. logical
2. integer
3. double
4. complex
5. character

Для проверки типа вектора используется функция typeof(), в которую передаётся 
вектор. Так как это полноценная функция, она возвращает строков вектор единичной
длины с названием типа данных переданного вектора.

``` {r}
x1 <- TRUE
typeof(x1)
x2 <- c(x1, 2L)
typeof(x2)
x3 <- c(x2, 3.1, Inf, NaN)
typeof(x3)
x4 <- c(x3, 4 + 5i)
typeof(x4)
x5 <- c(x4, "6")
typeof(x5)
```

Наша ИСТИНА из первого вектора проделала долгий путь приведения типов.

Система типов в R иднамическая и слабая. Явно приводить типы можно функциями
as.<название типа>

```{r}
as.integer(TRUE)
as.logical("sdgsb")
as.character(2+4i)
as.double(1L)
as.complex(5)
```

А проверять вектор на принадлежность определённому типу можно функциями
is.<название типа>

``` {r}
is.logical(TRUE)
is.logical(NA)
is.integer(c(1L, NA))
is.character("Hello")
```

## Простые операторы и функции над векторами

Арифметические операции:

``` {r}
5 + 2
3 - 1
2.1 * 0.7
100 / 3
100 %/% 3
100 %% 3
2 ^ 8
```

Напоминаю, что скаляров в R нет. И сейчас мы складывали, делили, умножали и 
возводили в степень векторы единичной длины. И все указанные выше операции 
определены и для векторов большей длины. При этом операторы применяются 
поэлементно. То есть складывая два вектора, вы складываете элемент первого
с соответствующим элементов второго. А если векторы разной длины, то более 
короткий будет переиспользован N раз, где N - целочисленное деление длины
длинного на длину короткого. Остаток от этого деление - количество элеементов
короткого, которыми будет заполнен остаток. Проще показать на примере:

``` {r}
c(3, 2, 1) + c(1, 2) == c(3 + 1, 2 + 2, 1 + 1)
10:16 - 1:2 == c(10 - 1, 11 - 2, 12 - 1, 13 - 2, 14 - 1, 15 - 2, 16 - 1)
```

Это называется рециркуляцией векторов

Логические операторы и функции:

``` {r}
5 > 3
5 < 3
1 >= 1
2 <= 3
(0.1 + 0.2) == 0.3
1 != 2

# Логические операторы также векторизованы
1:10 > 5:10
LETTERS == toupper(letters)

# AND, OR, NOT

c(TRUE, FALSE) & c(FALSE, TRUE)
c(TRUE, FALSE) && c(FALSE, TRUE)

c(TRUE, FALSE) | c(FALSE, TRUE)
c(TRUE, FALSE) || c(FALSE, TRUE)

! c(TRUE, FALSE)

xor(c(TRUE, FALSE, TRUE), c(FALSE, TRUE, TRUE))

is.logical(TRUE)
is.na(NA)

```

Индексы.

Индексы векторов начинаются с единицы, как в математике, а не с нуля, как в
привычном программировании. Выбор определённых элементов вектора может быть 
осуществлён подстановкой в квадратные скобки выражения, которое возвращает 
целочисленный или логический вектор. В первом случае выбираются элементы вектора
с соответствующими индексами. Во втором - все, для которых в логическом векторе
стоит TRUE. Целочисленные индексы могут быть отрицательными. Тогда возвращается
вектор со всеми эдементами, кроме тех, чей индекс указан отрицательным

``` {r}
# создадим вектор, который будем индексировать

rnf <- runif(100, min = -10, max = 10)

rnf[1] # возвращается первый элемент
rnf[-1] # возвращаются все элементы, кроме первого

positive <- which(rnf > 0)

# три следующих выражения абсолютно идентичны
rnf[positive]
rnf[which(rnf > 0)]
rnf[rnf > 0]

all.equal(rnf[positive], rnf[which(rnf > 0)])
all.equal(rnf[rnf > 0], rnf[which(rnf > 0)])
all.equal(rnf[positive], rnf[rnf > 0])

# использование отрицательных индексов
rnf[-positive]
rnf[-which(rnf > 0)]
rnf[! rnf > 0]

# специальные варианты функции which

rnf[which.max(rnf)]
rnf[which.min(rnf)]

rnf[(rnf == max(rnf))]
```

Простые функции:

``` {r}
x <- 1:10
length(x)
sum(x)
y <- rep(2, 7)
unique(y)
unique(c(x, y))

prod(x)

rnd <- rnorm(1000, mean = 42, sd = 7)

mean(rnd)
mean(rnd, trim = 0.2)
sd(c(rnd, NA))
sd(c(rnd, NA), na.rm = TRUE)
plot(rnd)

max(rnd)
min(rnd)
```

## Ветвления

R интерпретируемый язык. Это значит, что скрипты (текстовые файлы с набором 
команд) в нём выполняются только с помощью интерпретатора. Компилируемые языки
могут превращать файлы с инструкциями в исполняемые системой файлы.

Для ветвления процесса выполнения команд, то есть для выполнения разных команд
в случае наступления разных условий используются специальные операторы

``` {r}

if (condition) {
  # do first thing
} else if (another_condition) {
  # do second thing
} else {
  # do third thing
}

# Использовать все части не обязательно

if (condition) {
  # do first thing
} else {
  # do second thing
}

# короткие выражения можно писать в одну строку

if (condition) x <- 100 else x <- 50

# если нужно проверить только одно условие и не нужно выполнять ничего,
# если оно не наступает

if (condition) x <- 100
```

Условие в скобках после if или else if должно быть логического типа и длиной 
один. Если передадите условие больше длины, будет выведено предупреждение и
использоваться будет только первый элемент.

R код больше похож на последовательность вычислений, а не команд. И вот для
условных вычислений (то есть расчёта значений элементов вектора по условиям)
существует функция ifelse. В качестве первого аргумента она принимает 
логический вектор, в качестве второго - вектор, откуда будут браться элементы,
если в условии TRUE, в качестве второго - источник элементов для условия FALSE.

``` {r}
x <- runif(100, -10, 10)
y <- rnorm(100, 100, 33)
z <- 1:100

ifelse(x > 0, 'positive', 'negative')

# приведение типов
ifelse(x > 0, 'positive', 0)
ifelse(x > 0, 1, 'negative')

# использование единичных векторов не обязательно, а вообще даже частный
# случай рециркуляции. В общем случае ожидаются векторы одинаковой длины

ifelse(x > 0, y, z)
```