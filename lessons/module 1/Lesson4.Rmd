---
title: "Урок четвертый: Работа с data.frame: фильтрация и преобразование"
author: "Вячеслав Арбузов"
date: "`r Sys.Date()`"
output: html_document
---

## Матрицы и массивы: расширение векторов

### Датафреймы

Датафреймы - это аналог таблицы в «Excel». Датафрейм может хранить разные типы данных в столбцах.В этих таблицах: строки – наблюдения, столбцы – переменные.
Датафреймы наследуют свойства матрицы и списка
Все в R является векторами, поэтому датафрейм фактически список векторов одинаковой длины уложенный по столбцам.


``` {r}
  # создаем датафрейм
  df = data.frame(
	a = letters[1:5],
	b = 1:5,
	c = rnorm(5),
	d = rnorm(5)>0
  )	
 df
 # структура и измерения
 str(df)
 length(df)
 nrow(df)
 ncol(df)
 # названия измерений
 dim(df)
 # названия
 names(df)
 colnames(df)
 dimnames(df)
 # индексация
 rownames(df)

```

## Добавление строк

Рассмотрим разные методы добавления строк

``` {r}
  # классы перед добавлением строки
  str(df)
  # добавляем строку
  # метод 1
  df[nrow(df) + 1,] = list('f',as.integer(6),0.123,F)
  # классы датафрейма после добавления методом 1 не изменились
  str(df)
  
  # метод 2
  # df[nrow(df) + 1,] = c('f',6,0) # not run - error
  df[nrow(df) + 1,] = c(1,2,3,4)
  # классы датафрейма после добавления методом 2 
  # R пытается преобразовать все новые строки к numeric (т.к. новый вектор числовой), если не получается 
  # оставляет как есть
  str(df)

  df[nrow(df) + 1,] = c('f',6,0,F)
  # классы датафрейма после добавления методом 2 
  # R пытается преобразовать все новые строки к character т.к. 
  # новый вектор символьный (вектор символьный из-за первого элемента 'f')
  str(df)
  


  # метод 3
  df2 = data.frame(list('f',6,0,F))
  names(df2) = names(df)
  newdf <- rbind(df, df2)

```

## Добавление столбцов

Рассмотрим разные методы добавления столбцов

``` {r}
# добавляем столбец
  # метод 1
  df$new = 1
  df$new2 = c(1,2,3,4)
  # df$not_run = c(1,2,3)
  df

  # метод 2
  df[,ncol(df)+1]= NA
  df

 # метод 3
  df['newcol']= 3
  df

 # метод 4
 df = data.frame(df,3,5)
 df

 # метод 5
 df = cbind(df,'a')
 df


```

## Удаление строк/столбцов


Рассмотрим разные методы добавления столбцов
Добавление '–' перед строкой/столбцов удаляет необходимые данные

``` {r}
df

# удаление первой строки
df = df[-1,]
df

# удаление первого столбца
df = df[,-1]
df
 


```
## Изменение значений в ячейке

Сперва выборка данных, а после присвоение


``` {r}
df
# присвоение одной ячейке
df[1,2] = 3
df

# изменение группы ячеек

df[1:2,3]=c(1,3)
df

df[1,2:3]=c(7,7)
df

# не рекомендую пока
# edit(df)


str(df)
# изменим тип столбца 
df$c = as.numeric(df$c)
str(df)

```
## Индексирование и выборка


``` {r}
# индексов в датафреймах нет в как в питоновской pandas им служат названия строк
df[,]
df[1,1]
df[[3]]
df[1:3,1:3]
df['b']
df[1:3,-c(1,4)]
df[-(1:2),]
# df['b'][1:2] # ошибка
df[,1,drop=T][1:3]
df[,c('b','d')]
df[c(F,T,T,T),]
head(df)
tail(df)

rownames(df) = letters[1:nrow(df)]
df
df['a',]

```
## Фильтрация




``` {r}
df
# метод 1
df[df$b>3,]
df[which(df$b>3),]
which(df$b>3) 
df[df$b>3 & df$b<5,]
df[rowSums(df[,4:5])>4,]

# метод 2
subset(df, b > 5)
subset(df, b > 3, select = c(b, c))

# метод 3
# View(df)

#сортировка
df[order(df[,1]),]

```
## Агрегирование

``` {r}
data(swiss)
swiss
swiss$conton = rownames(swiss)
swiss$high_ed = swiss$Education>20
df1 = swiss[1:3,]
df1
df2 = swiss[5:9,]
df2

#соединение по столбцам
rbind(df1,df2)

df1 = swiss[,1]
df1
df2 = swiss[,1:2]
df2
#соединение по строкам
rbind(df1,df2)

df1 = data.frame(letters[1:10],1:10)
df1
df2 = data.frame(letters[2:12],2:12)
df2
colnames(df1) = c('a1','a2')
colnames(df2) = c('a1','a3')
merge(df1,df2,by = 'a1')
merge(df1,df2,by.x = 'a1',by.y = 'a1')
# full join
merge(df1,df2,by.x = 'a1',by.y = 'a1',all = TRUE)
# inner join
merge(df1,df2,by.x = 'a1',by.y = 'a1',all = FALSE)
# left join
merge(df1,df2,by.x = 'a1',by.y = 'a1',all.x = T) 
# right join
merge(df1,df2,by.x = 'a1',by.y = 'a1',all.y = T) 

# функция aggregate
# aggregate(x, by, FUN)
df
# метод агрегирования 1
aggregate(df[,4:5],by = df['b'],sum)

# метод агрегирования 2
aggregate(x = df, by = list(df$b), FUN = "mean")

# метод агрегирования 3
# для избегания ошибки по преобразованию данных (как в методе 2)
# можно написать функцию которая преобразуем в число перед вычислением средней
# и игнорируем пропущенные значения
# function(x) mean(as.numeric(x),na.rm = TRUE)
#
# запись .~b означает что все переменные зависят от b (синтаксис функции lm)
aggregate(.~b, df[,1:5], function(x) mean(as.numeric(x),na.rm = TRUE))


```